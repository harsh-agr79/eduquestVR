<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Object Creator - Meta Quest 2 Compatible</title>
    <style>
        :root {
            --color-primary: #646cff;
            --color-primary-hover: #747bff;
            --color-secondary: #535bf2;
            --color-background: #242424;
            --color-surface: #1a1a1a;
            --color-text: rgba(255, 255, 255, 0.87);
            --color-border: #444;
            --color-success: #4caf50;
            --color-warning: #ff9800;
            --color-error: #f44336;
            --color-info: #2196f3;
            
            --font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
            --font-size-sm: 0.875rem;
            --font-size-md: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
            
            --space-4: 0.25rem;
            --space-8: 0.5rem;
            --space-12: 0.75rem;
            --space-16: 1rem;
            --space-24: 1.5rem;
            --space-32: 2rem;
            
            --border-radius: 8px;
            --border-radius-lg: 12px;
            
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            font-family: var(--font-family);
            line-height: 1.5;
            font-weight: 400;
            color: var(--color-text);
            background-color: var(--color-background);
            overflow: hidden;
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: var(--space-16);
            gap: var(--space-16);
            pointer-events: none;
            z-index: 100;
        }

        .card {
            background-color: var(--color-surface);
            border-radius: var(--border-radius);
            padding: var(--space-16);
            box-shadow: var(--shadow);
            pointer-events: auto;
            max-width: 400px;
        }

        .card__body {
            display: flex;
            flex-direction: column;
            gap: var(--space-12);
        }

        h3, h4, h5 {
            color: var(--color-text);
            margin-bottom: var(--space-8);
        }

        h3 {
            font-size: var(--font-size-xl);
        }

        h4 {
            font-size: var(--font-size-lg);
        }

        h5 {
            font-size: var(--font-size-md);
        }

        p {
            margin-bottom: var(--space-12);
        }

        .status-indicators {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .status {
            display: flex;
            align-items: center;
            gap: var(--space-8);
            padding: var(--space-8) var(--space-12);
            border-radius: var(--border-radius);
            font-size: var(--font-size-sm);
        }

        .status--success {
            background-color: rgba(76, 175, 80, 0.2);
            color: var(--color-success);
        }

        .status--warning {
            background-color: rgba(255, 152, 0, 0.2);
            color: var(--color-warning);
        }

        .status--error {
            background-color: rgba(244, 67, 54, 0.2);
            color: var(--color-error);
        }

        .status--info {
            background-color: rgba(33, 150, 243, 0.2);
            color: var(--color-info);
        }

        .loading {
            width: 12px;
            height: 12px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-8) var(--space-16);
            border-radius: var(--border-radius);
            border: 1px solid transparent;
            font-size: var(--font-size-md);
            font-weight: 500;
            font-family: inherit;
            background-color: var(--color-primary);
            color: white;
            cursor: pointer;
            transition: all 0.25s;
            text-decoration: none;
        }

        .btn:hover {
            background-color: var(--color-primary-hover);
        }

        .btn:focus,
        .btn:focus-visible {
            outline: 4px auto -webkit-focus-ring-color;
        }

        .btn--sm {
            padding: var(--space-4) var(--space-12);
            font-size: var(--font-size-sm);
        }

        .btn--primary {
            background-color: var(--color-primary);
        }

        .btn--secondary {
            background-color: var(--color-secondary);
        }

        .btn--outline {
            background-color: transparent;
            border: 1px solid var(--color-primary);
            color: var(--color-primary);
        }

        .btn--outline:hover {
            background-color: rgba(100, 108, 255, 0.1);
        }

        .creation-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-8);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .model-select {
            padding: var(--space-8);
            border-radius: var(--border-radius);
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            color: var(--color-text);
            font-size: var(--font-size-sm);
        }

        .mt-8 {
            margin-top: var(--space-8);
        }

        ul {
            padding-left: var(--space-24);
            margin-bottom: var(--space-12);
        }

        li {
            margin-bottom: var(--space-4);
        }

        .error-card {
            border-left: 4px solid var(--color-error);
        }

        .troubleshooting-card {
            border-left: 4px solid var(--color-warning);
        }

        .error-header,
        .troubleshoot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-12);
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--color-text);
            font-size: var(--font-size-xl);
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .troubleshoot-section {
            margin-bottom: var(--space-16);
        }

        .troubleshoot-section h5 {
            margin-bottom: var(--space-8);
        }

        .troubleshoot-section ol {
            padding-left: var(--space-24);
        }

        .hidden {
            display: none !important;
        }

        #vr-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding: var(--space-32);
        }

        .vr-ui {
            background-color: rgba(26, 26, 26, 0.8);
            border-radius: var(--border-radius-lg);
            padding: var(--space-16);
            backdrop-filter: blur(10px);
            text-align: center;
        }

        .vr-status {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .vr-text {
            font-size: var(--font-size-lg);
            font-weight: bold;
        }

        .vr-hint {
            font-size: var(--font-size-sm);
            opacity: 0.8;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-background);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-24);
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-top: 5px solid var(--color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        #loading-steps {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
            text-align: left;
        }

        .loading-step {
            font-size: var(--font-size-md);
            color: var(--color-text);
        }

        .loading-step.completed {
            color: var(--color-success);
        }

        .delete-active {
            background-color: var(--color-error) !important;
            color: white !important;
        }
    </style>
    
    <!-- Three.js r150+ for proper WebXR support -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/"
        }
      }
    </script>
    
    <!-- WebXR Polyfill for better compatibility -->
    <script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.min.js"></script>
</head>
<body>
    <div id="container">
        <!-- Main Info Panel -->
        <div id="info" class="card">
            <div class="card__body">
                <h3>VR Object Creator</h3>
                <p id="main-description">Advanced VR/AR scene builder with Quest 2 support</p>
                
                <div class="status-indicators">
                    <div id="https-status" class="status status--info">
                        <span class="loading"></span> HTTPS: Checking...
                    </div>
                    <div id="webxr-status" class="status status--info">
                        <span class="loading"></span> WebXR: Checking...
                    </div>
                    <div id="vr-status" class="status status--info">
                        <span class="loading"></span> VR Support: Checking...
                    </div>
                    <div id="input-method" class="status status--warning">Input: Desktop</div>
                    <div id="object-count" class="status status--success">Objects: 0</div>
                </div>
                
                <div id="compatibility-info" class="mt-8">
                    <p><strong>Current Mode:</strong> <span id="current-mode">Desktop Fallback</span></p>
                </div>

                <!-- Desktop Creation Controls -->
                <div id="desktop-creation" class="mt-8">
                    <h4>Create Objects (Desktop Mode)</h4>
                    <div class="creation-buttons">
                        <button class="btn btn--sm create-btn" data-type="cube">üì¶ Cube</button>
                        <button class="btn btn--sm create-btn" data-type="sphere">‚ö™ Sphere</button>
                        <button class="btn btn--sm create-btn" data-type="cylinder">üóÑÔ∏è Cylinder</button>
                        <button class="btn btn--sm create-btn" data-type="cone">üî∫ Cone</button>
                        <button class="btn btn--sm create-btn" data-type="torus">üç© Torus</button>
                        <button class="btn btn--sm create-btn" data-type="tetrahedron">üíé Tetrahedron</button>
                        <button id="toggle-delete" class="btn btn--sm btn--outline">üóëÔ∏è Delete Mode: OFF</button>
                    </div>
                    
                    <!-- GLB Model Selection -->
                    <div class="control-group mt-8">
                        <h5>Load GLB Model</h5>
                        <select id="glb-model-select" class="model-select">
                            <option value="">Select a model...</option>
                            <option value="human_dna.glb">Human DNA</option>
                            <option value="skeleton.glb">Skeleton</option>
                            <option value="moto.glb">Motor</option>
                            <option value="engine.glb">Turbine</option>
                            <option value="model5.glb">Model 5</option>
                        </select>
                        <button id="load-glb-btn" class="btn btn--secondary">Load Selected Model</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Instructions Panel -->
        <div id="instructions" class="card">
            <div class="card__body">
                <h4>Controls</h4>
                <div id="vr-instructions" class="hidden">
                    <ul>
                        <li><strong>Controllers:</strong> Point and trigger to interact</li>
                        <li><strong>Hands:</strong> Point and pinch to grab objects</li>
                        <li><strong>Menu:</strong> Point at buttons to spawn objects</li>
                        <li><strong>Rotate:</strong> Grab object and twist controller/hand</li>
                        <li><strong>Delete:</strong> Select delete mode and point at objects</li>
                        <li><strong>GLB Models:</strong> Load via desktop mode first</li>
                    </ul>
                </div>
                <div id="desktop-instructions">
                    <ul>
                        <li><strong>Mouse:</strong> Click objects to interact</li>
                        <li><strong>Camera:</strong> Drag to orbit, scroll to zoom</li>
                        <li><strong>Create:</strong> Use buttons above to spawn objects</li>
                        <li><strong>WASD:</strong> Alternative camera movement</li>
                        <li><strong>Delete:</strong> Toggle delete mode, then click objects</li>
                        <li><strong>GLB Models:</strong> Select from dropdown and click load</li>
                        <li><strong>Keyboard:</strong> C=Cube, S=Sphere, T=Torus, D=Delete Mode</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- Error/Warning Panel -->
        <div id="error-panel" class="card error-card hidden">
            <div class="card__body">
                <div class="error-header">
                    <div class="status status--error">
                        <strong>WebXR Issues Detected</strong>
                    </div>
                    <button id="close-error" class="close-btn">√ó</button>
                </div>
                <div id="error-list" class="mt-8">
                    <!-- Dynamic error content -->
                </div>
            </div>
        </div>
        
        <!-- Troubleshooting Panel -->
        <div id="troubleshooting" class="card troubleshooting-card hidden">
            <div class="card__body">
                <div class="troubleshoot-header">
                    <h4>üîß Troubleshooting Guide</h4>
                    <button id="close-troubleshoot" class="close-btn">√ó</button>
                </div>
                <div id="troubleshooting-content">
                    <div class="troubleshoot-section">
                        <h5>For Meta Quest 2:</h5>
                        <ol>
                            <li>Open Quest Browser or use Oculus Link</li>
                            <li>Navigate to this page via HTTPS</li>
                            <li>Allow VR permissions when prompted</li>
                            <li>Look for "Enter VR" button</li>
                        </ol>
                    </div>
                    
                    <div class="troubleshoot-section">
                        <h5>For Desktop Chrome:</h5>
                        <ol>
                            <li>Chrome 79+ required</li>
                            <li>Enable WebXR flags: chrome://flags/#webxr-incubations</li>
                            <li>Connect VR headset</li>
                            <li>Use HTTPS (required for WebXR)</li>
                        </ol>
                    </div>
                    
                    <div class="troubleshoot-section">
                        <h5>For Firefox:</h5>
                        <ol>
                            <li>Firefox 98+ recommended</li>
                            <li>Enable dom.vr.webxr.enabled in about:config</li>
                            <li>Restart browser after enabling</li>
                        </ol>
                    </div>
                </div>
                
                <button id="retry-webxr" class="btn btn--primary mt-8">
                    üîÑ Retry WebXR Detection
                </button>
            </div>
        </div>
    </div>
    
    <!-- VR Overlay (shown when in VR) -->
    <div id="vr-overlay" class="hidden">
        <div class="vr-ui">
            <div class="vr-status">
                <div class="vr-text">ü•Ω VR Mode Active</div>
                <span id="vr-object-count">Objects: 0</span>
                <span id="vr-mode-indicator">Mode: Create</span>
                <div class="vr-hint">Look around and use controllers to interact</div>
            </div>
        </div>
    </div>

    <!-- Add to your desktop-creation section -->
    <div class="control-group mt-8">
        <h5>Sun Position</h5>
        <div class="creation-buttons">
            <button id="sun-morning" class="btn btn--sm">üåÖ Morning</button>
            <button id="sun-noon" class="btn btn--sm">‚òÄÔ∏è Noon</button>
            <button id="sun-evening" class="btn btn--sm">üåá Evening</button>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <p>Initializing VR Application...</p>
            <div id="loading-steps">
                <div class="loading-step">‚úì Loading Three.js</div>
                <div class="loading-step" id="step-webxr">‚è≥ Checking WebXR support</div>
                <div class="loading-step" id="step-scene">‚è≥ Creating 3D scene</div>
                <div class="loading-step" id="step-vr">‚è≥ Setting up VR</div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the required loaders
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Enhanced VR Object Creator with comprehensive WebXR support
        class VRObjectCreator {
            constructor() {
                // Core Three.js components
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;

                // Headlamp light
                this.headlamp = null;
                this.headlampIntensity = 0.8;
                this.headlampEnabled = true;
                
                // VR components
                this.controllers = [];
                this.hands = [];
                this.raycasters = [];
                
                // Scene objects
                this.objects = [];
                this.menu = null;
                this.menuButtons = [];
                this.room = null;
                this.platform = null;
                this.tables = [];
                
                // Interaction state
                this.selectedObject = null;
                this.grabbedObject = null;
                this.grabbedController = null;
                this.isDeleteMode = false;
                this.objectCount = 0;
                
                // Input handling
                this.mouse = new THREE.Vector2();
                this.mouseRaycaster = new THREE.Raycaster();
                this.inputMethod = 'desktop';
                
                // WebXR compatibility
                this.webXRSupported = false;
                this.vrSessionAvailable = false;
                this.httpsRequired = !this.isHTTPS();
                this.compatibilityIssues = [];
                
                // Grab interaction
                this.grabOffset = new THREE.Vector3();
                this.grabRotationOffset = new THREE.Quaternion();
                
                // GLB loader
                this.gltfLoader = new GLTFLoader();
                
                this.init();
            }

            async init() {
                try {
                    this.showLoadingStep('step-webxr', '‚è≥ Checking WebXR support');
                    
                    // Check compatibility first
                    await this.checkWebXRCompatibility();
                    this.updateCompatibilityUI();
                    
                    this.showLoadingStep('step-scene', '‚è≥ Creating 3D scene');
                    this.createScene();
                    this.createRoom();
                    this.createPlatform();
                    this.createTables();
                    this.createMenu();
                    this.setupLights();
                    
                    this.showLoadingStep('step-vr', '‚è≥ Setting up VR');
                    await this.setupVR();
                    
                    this.setupEventListeners();
                    this.animate();
                    this.updateUI();
                    
                    // Hide loading overlay
                    setTimeout(() => {
                        document.getElementById('loading-overlay').classList.add('hidden');
                    }, 1000);

                    console.log('VR Object Creator initialized successfully');
                    
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.showLoadingError(error.message);
                }
            }

            showLoadingError(message) {
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.innerHTML = `
                        <div class="loading-content">
                            <div style="color: var(--color-error); font-size: var(--font-size-xl); margin-bottom: var(--space-16);">
                                ‚ùå Application Failed to Load
                            </div>
                            <div style="font-size: var(--font-size-md); margin-bottom: var(--space-16);">
                                ${message}
                            </div>
                            <button onclick="location.reload()" class="btn btn--primary">
                                üîÑ Reload Page
                            </button>
                        </div>
                    `;
                }
            }

            isHTTPS() {
                return location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            }

            async checkWebXRCompatibility() {
                const issues = [];
                
                // Check HTTPS
                if (!this.isHTTPS()) {
                    issues.push({
                        type: 'https',
                        message: 'HTTPS required for WebXR',
                        solution: 'Access this page via HTTPS or localhost'
                    });
                }
                
                // Check navigator.xr
                if (!('xr' in navigator)) {
                    issues.push({
                        type: 'webxr-api',
                        message: 'WebXR not available in this browser',
                        solution: 'Use Chrome 79+, Firefox 98+, or Quest Browser'
                    });
                } else {
                    this.webXRSupported = true;
                    
                    try {
                        // Check VR session support
                        const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
                        this.vrSessionAvailable = vrSupported;
                        
                        if (!vrSupported) {
                            issues.push({
                                type: 'vr-session',
                                message: 'VR sessions not supported',
                                solution: 'Connect a VR headset or enable WebXR flags'
                            });
                        }
                    } catch (error) {
                        console.warn('VR support check failed:', error);
                        issues.push({
                            type: 'vr-check-failed',
                            message: 'Failed to check VR support',
                            solution: 'Check browser WebXR flags or permissions'
                        });
                    }
                }
                
                this.compatibilityIssues = issues;
            }

            updateCompatibilityUI() {
                // Update HTTPS status
                const httpsStatus = document.getElementById('https-status');
                if (this.isHTTPS()) {
                    httpsStatus.className = 'status status--success';
                    httpsStatus.innerHTML = '‚úÖ HTTPS: Secure';
                } else {
                    httpsStatus.className = 'status status--error';
                    httpsStatus.innerHTML = '‚ùå HTTPS: Required';
                }
                
                // Update WebXR status
                const webxrStatus = document.getElementById('webxr-status');
                if (this.webXRSupported) {
                    webxrStatus.className = 'status status--success';
                    webxrStatus.innerHTML = '‚úÖ WebXR: Available';
                } else {
                    webxrStatus.className = 'status status--error';
                    webxrStatus.innerHTML = '‚ùå WebXR: Not Available';
                }
                
                // Update VR status
                const vrStatus = document.getElementById('vr-status');
                if (this.vrSessionAvailable) {
                    vrStatus.className = 'status status--success';
                    vrStatus.innerHTML = '‚úÖ VR Support: Ready';
                } else if (this.webXRSupported) {
                    vrStatus.className = 'status status--warning';
                    vrStatus.innerHTML = '‚ö†Ô∏è VR Support: Limited';
                } else {
                    vrStatus.className = 'status status--error';
                    vrStatus.innerHTML = '‚ùå VR Support: None';
                }
                
                // Show error/troubleshooting panels if needed
                if (this.compatibilityIssues.length > 0) {
                    this.showCompatibilityIssues();
                }
                
                // Update current mode
                const modeElement = document.getElementById('current-mode');
                if (this.vrSessionAvailable) {
                    modeElement.textContent = 'VR Ready';
                    modeElement.style.color = 'var(--color-success)';
                } else {
                    modeElement.textContent = 'Desktop Fallback';
                    modeElement.style.color = 'var(--color-warning)';
                }
            }

            showCompatibilityIssues() {
                const errorPanel = document.getElementById('error-panel');
                const errorList = document.getElementById('error-list');
                const troubleshooting = document.getElementById('troubleshooting');
                
                // Build error list
                let errorHTML = '<ul>';
                this.compatibilityIssues.forEach(issue => {
                    errorHTML += `<li><strong>${issue.message}</strong><br><small>${issue.solution}</small></li>`;
                });
                errorHTML += '</ul>';
                
                errorList.innerHTML = errorHTML;
                errorPanel.classList.remove('hidden');
                troubleshooting.classList.remove('hidden');
            }

            showLoadingStep(stepId, text) {
                const step = document.getElementById(stepId);
                if (step) {
                    step.textContent = text;
                    step.classList.add('completed');
                }
            }

            createScene() {
                // Scene
               this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
                this.scene.fog = new THREE.Fog(0x87CEEB, 5, 20); // Light blue fog for depth

                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 1.6, 3);

                // Renderer with enhanced settings
                // Renderer with enhanced settings
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: 'high-performance'
                });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
                this.renderer.shadowMap.autoUpdate = true;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0; // Slightly reduced for better contrast
                
                document.body.appendChild(this.renderer.domElement);

                // Desktop controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.target.set(0, 1.6, 0);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 10;
                this.controls.maxPolarAngle = Math.PI / 1.8;
                this.controls.update();
            }

         createRoom() {
            const roomGroup = new THREE.Group();
            const { width, height, depth } = { width: 10, height: 4, depth: 10 };
            
            // Enhanced materials with textures
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B7355,
                transparent: true,
                opacity: 0.9
            });
            
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x654321
            });

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(width, depth);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            roomGroup.add(floor);

            // Walls
            const wallGeometry = new THREE.PlaneGeometry(width, height);
            
            // Back wall
            const backWall = new THREE.Mesh(wallGeometry.clone(), wallMaterial.clone());
            backWall.position.set(0, height / 2, -depth / 2);
            roomGroup.add(backWall);

            // Front wall (partial for entrance)
            const frontWall = new THREE.Mesh(wallGeometry.clone(), wallMaterial.clone());
            frontWall.position.set(0, height / 2, depth / 2);
            frontWall.rotation.y = Math.PI;
            roomGroup.add(frontWall);

            // Side walls
            const sideWallGeometry = new THREE.PlaneGeometry(depth, height);
            
            const leftWall = new THREE.Mesh(sideWallGeometry.clone(), wallMaterial.clone());
            leftWall.position.set(-width / 2, height / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            roomGroup.add(leftWall);

            const rightWall = new THREE.Mesh(sideWallGeometry.clone(), wallMaterial.clone());
            rightWall.position.set(width / 2, height / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            roomGroup.add(rightWall);

            this.room = roomGroup;
            this.scene.add(roomGroup);
        }
            createPlatform() {
                const platformGeometry = new THREE.BoxGeometry(4, 0.2, 4);
                const platformMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513
                });
                
                this.platform = new THREE.Mesh(platformGeometry, platformMaterial);
                this.platform.position.set(0, 0.1, 0);
                this.platform.castShadow = true;
                this.platform.receiveShadow = true;
                this.scene.add(this.platform);
            }

            createTables() {
                const tablePositions = [
                    { x: 2, y: 0.4, z: 2 },
                    { x: -2, y: 0.4, z: -2 }
                ];

                tablePositions.forEach((pos, index) => {
                    const tableGroup = new THREE.Group();
                    
                    // Table top
                    const topGeometry = new THREE.BoxGeometry(1.5, 0.1, 1);
                    const topMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const top = new THREE.Mesh(topGeometry, topMaterial);
                    top.position.y = 0.4;
                    top.castShadow = true;
                    top.receiveShadow = true;
                    tableGroup.add(top);

                    // Table legs
                    const legGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.1);
                    const legMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                    
                    const legPositions = [
                        [-0.7, 0, -0.4], [0.7, 0, -0.4],
                        [-0.7, 0, 0.4], [0.7, 0, 0.4]
                    ];
                    
                    legPositions.forEach(legPos => {
                        const leg = new THREE.Mesh(legGeometry.clone(), legMaterial.clone());
                        leg.position.set(legPos[0], legPos[1], legPos[2]);
                        leg.castShadow = true;
                        tableGroup.add(leg);
                    });

                    tableGroup.position.set(pos.x, pos.y, pos.z);
                    this.tables.push(tableGroup);
                    this.scene.add(tableGroup);
                });
            }

            createMenu() {
                const menuGroup = new THREE.Group();
                menuGroup.position.set(0, 2.5, -3);

                // Menu background
                const menuBg = new THREE.Mesh(
                    new THREE.PlaneGeometry(4, 1.8),
                    new THREE.MeshLambertMaterial({ 
                        color: 0x333333, 
                        transparent: true, 
                        opacity: 0.9
                    })
                );
                menuGroup.add(menuBg);

                // Menu title
                const titleGeometry = new THREE.PlaneGeometry(2, 0.3);
                const titleMaterial = new THREE.MeshLambertMaterial({ color: 0x00FFFF });
                const title = new THREE.Mesh(titleGeometry, titleMaterial);
                title.position.set(0, 0.6, 0.01);
                menuGroup.add(title);

                // Object creation buttons
                const objectTypes = ['cube', 'sphere', 'cylinder', 'cone', 'torus', 'tetrahedron', 'glb'];
                const buttonWidth = 0.5;
                const buttonHeight = 0.3;
                const buttonsPerRow = 3;
                
                this.menuButtons = [];
                
                objectTypes.forEach((type, index) => {
                    const row = Math.floor(index / buttonsPerRow);
                    const col = index % buttonsPerRow;
                    const x = (col - 1) * (buttonWidth + 0.2);
                    const y = 0.1 - row * (buttonHeight + 0.15);

                    const buttonGeometry = new THREE.PlaneGeometry(buttonWidth, buttonHeight);
                    const buttonMaterial = new THREE.MeshLambertMaterial({ 
                        color: this.getObjectColor(type),
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
                    button.position.set(x, y, 0.02);
                    button.userData = { 
                        type: 'menuButton', 
                        objectType: type,
                        originalColor: this.getObjectColor(type),
                        originalOpacity: 0.8
                    };
                    
                    this.menuButtons.push(button);
                    menuGroup.add(button);
                });

                // Delete mode button
                const deleteButton = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.2, 0.3),
                    new THREE.MeshLambertMaterial({ 
                        color: 0xFF0000, 
                        transparent: true, 
                        opacity: 0.8 
                    })
                );
                deleteButton.position.set(0, -0.6, 0.02);
                deleteButton.userData = { 
                    type: 'deleteButton',
                    originalColor: 0xFF0000,
                    originalOpacity: 0.8
                };
                this.menuButtons.push(deleteButton);
                menuGroup.add(deleteButton);

                this.menu = menuGroup;
                this.scene.add(menuGroup);
            }

            getObjectColor(type) {
                const colors = {
                    cube: 0xFF6B6B,
                    sphere: 0x4ECDC4,
                    cylinder: 0x45B7D1,
                    cone: 0xF39C12,
                    torus: 0x9B59B6,
                    tetrahedron: 0x2ECC71,
                    glb: 0x888888
                };
                return colors[type] || 0xFFFFFF;
            }

            async setupVR() {
                // Only setup VR if WebXR is supported
                if (!this.webXRSupported) {
                    console.log('WebXR not supported, using desktop fallback');
                    return;
                }

                try {
                    // Enable XR on renderer
                    this.renderer.xr.enabled = true;

                    // Create VR button only if VR sessions are supported
                    if (this.vrSessionAvailable) {
                        const vrButton = VRButton.createButton(this.renderer, {
                            onUnsupported: () => {
                                console.log('VR not supported');
                                this.showVRError('VR headset not detected or not supported');
                            }
                        });
                        document.body.appendChild(vrButton);
                        console.log('VR button created and added to DOM');
                    } else {
                        console.log('VR sessions not available, no VR button created');
                    }

                    // Setup controllers
                    await this.setupControllers();
                    
                } catch (error) {
                    console.error('VR setup failed:', error);
                    this.showVRError('Failed to initialize VR: ' + error.message);
                }
            }

            async setupControllers() {
                if (!this.renderer.xr) return;

                try {
                    // Controller 1
                    const controller1 = this.renderer.xr.getController(0);
                    controller1.addEventListener('selectstart', (e) => this.onSelectStart(e, 0));
                    controller1.addEventListener('selectend', (e) => this.onSelectEnd(e, 0));
                    controller1.addEventListener('connected', (e) => this.onControllerConnected(e, 0));
                    controller1.addEventListener('disconnected', () => this.onControllerDisconnected(0));
                    this.controllers.push(controller1);
                    this.scene.add(controller1);

                    // Controller 2
                    const controller2 = this.renderer.xr.getController(1);
                    controller2.addEventListener('selectstart', (e) => this.onSelectStart(e, 1));
                    controller2.addEventListener('selectend', (e) => this.onSelectEnd(e, 1));
                    controller2.addEventListener('connected', (e) => this.onControllerConnected(e, 1));
                    controller2.addEventListener('disconnected', () => this.onControllerDisconnected(1));
                    this.controllers.push(controller2);
                    this.scene.add(controller2);

                    // Add visual ray indicators
                    this.controllers.forEach(controller => {
                        const line = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(0, 0, 0),
                            new THREE.Vector3(0, 0, -1)
                        ]);
                        const rayLine = new THREE.Line(line, new THREE.LineBasicMaterial({ 
                            color: 0x00FFFF,
                            linewidth: 2
                        }));
                        rayLine.scale.z = 2;
                        controller.add(rayLine);
                    });

                    // Add controller grips for better visual feedback
                    const controllerGrip1 = this.renderer.xr.getControllerGrip(0);
                    const controllerGrip2 = this.renderer.xr.getControllerGrip(1);
                    this.scene.add(controllerGrip1);
                    this.scene.add(controllerGrip2);
                    
                } catch (error) {
                    console.warn('Controller setup failed:', error);
                }
            }

           setupLights() {
                // Remove any existing lights
                this.scene.children.forEach(child => {
                    if (child.isLight) {
                        this.scene.remove(child);
                    }
                });

                // Soft ambient light for overall illumination
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                // Main directional light (simulating sun)
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainLight.position.set(5, 10, 7);
                mainLight.castShadow = true;
                
                // Soft shadow settings
                mainLight.shadow.mapSize.width = 1024;
                mainLight.shadow.mapSize.height = 1024;
                mainLight.shadow.camera.near = 0.5;
                mainLight.shadow.camera.far = 50;
                mainLight.shadow.camera.left = -10;
                mainLight.shadow.camera.right = 10;
                mainLight.shadow.camera.top = 10;
                mainLight.shadow.camera.bottom = -10;
                mainLight.shadow.radius = 3; // Soft shadows
                mainLight.shadow.bias = -0.0001;
                
                this.scene.add(mainLight);

                // Fill light from the opposite direction
                const fillLight = new THREE.DirectionalLight(0x7777ff, 0.3);
                fillLight.position.set(-5, 5, -5);
                this.scene.add(fillLight);

                // Back light for rim lighting effect
                const backLight = new THREE.DirectionalLight(0xffffff, 0.2);
                backLight.position.set(0, 5, -10);
                this.scene.add(backLight);

                // Additional soft lights from sides
                const leftLight = new THREE.DirectionalLight(0x4455aa, 0.15);
                leftLight.position.set(-10, 5, 0);
                this.scene.add(leftLight);

                const rightLight = new THREE.DirectionalLight(0xaa4455, 0.15);
                rightLight.position.set(10, 5, 0);
                this.scene.add(rightLight);

                // Soft overhead light
                const topLight = new THREE.DirectionalLight(0xffffff, 0.25);
                topLight.position.set(0, 10, 0);
                this.scene.add(topLight);

                // Subtle ground bounce light
                const groundLight = new THREE.DirectionalLight(0x556677, 0.1);
                groundLight.position.set(0, -5, 0);
                this.scene.add(groundLight);

                // Add subtle point lights in corners for ambient fill
                const pointLight1 = new THREE.PointLight(0x4477aa, 0.3, 15);
                pointLight1.position.set(-4, 2, -4);
                this.scene.add(pointLight1);

                const pointLight2 = new THREE.PointLight(0xaa7744, 0.3, 15);
                pointLight2.position.set(4, 2, 4);
                this.scene.add(pointLight2);

                // Menu-specific lighting
                const menuLight = new THREE.SpotLight(0xffffff, 0.6);
                menuLight.position.set(0, 3, -2);
                menuLight.target = this.menu;
                menuLight.angle = Math.PI / 6;
                menuLight.penumbra = 0.5; // Softer edge
                menuLight.decay = 1.5;
                menuLight.distance = 10;
                this.scene.add(menuLight);

                // Add a subtle hemisphere light for environmental lighting
                const hemisphereLight = new THREE.HemisphereLight(0xaaaaff, 0x775533, 0.2);
                this.scene.add(hemisphereLight);

                this.setupHeadlamp();

                console.log("Enhanced soft lighting setup complete");
            }
            setupHeadlamp() {
                // Create a soft white light
                this.headlamp = new THREE.PointLight(0xffffff, this.headlampIntensity, 10, 2);
                this.headlamp.position.set(0, 0, 0);
                
                // Soft, dispersing light settings
                this.headlamp.decay = 2; // Faster decay for more natural falloff
                this.headlamp.distance = 8; // How far the light reaches
                
                // Add to camera so it moves with the view
                this.camera.add(this.headlamp);
                
                // Optional: Add a visible light source (small sphere)
                const lampGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const lampMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffcc,
                    emissive: 0xffff99,
                    emissiveIntensity: 0.5
                });
                const lampBulb = new THREE.Mesh(lampGeometry, lampMaterial);
                this.headlamp.add(lampBulb);
                
                console.log("Headlamp initialized");
            }
            onControllerConnected(event, index) {
                console.log(`Controller ${index} connected:`, event.data);
                this.inputMethod = 'vr-controllers';
                this.updateUI();
                
                // Show VR instructions
                document.getElementById('desktop-instructions').classList.add('hidden');
                document.getElementById('vr-instructions').classList.remove('hidden');
            }

            onControllerDisconnected(index) {
                console.log(`Controller ${index} disconnected`);
                if (this.grabbedController === index) {
                    this.onSelectEnd(null, index);
                }
            }

            onSelectStart(event, controllerIndex) {
                const controller = this.controllers[controllerIndex];
                if (!controller) return;

                const intersections = this.getIntersections(controller);
                if (intersections.length > 0) {
                    const intersection = intersections[0];
                    const object = intersection.object;
                    this.handleObjectInteraction(object, controller, controllerIndex);
                }
            }

            onSelectEnd(event, controllerIndex) {
                if (this.grabbedController === controllerIndex) {
                    this.releaseObject();
                }
            }

            getIntersections(controller) {
                const raycaster = new THREE.Raycaster();
                const tempMatrix = new THREE.Matrix4();
                
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                const intersectableObjects = [
                    ...this.objects,
                    ...this.menuButtons
                ];

                return raycaster.intersectObjects(intersectableObjects);
            }

            handleMouseInteraction(event) {
                // Update mouse position
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Update raycaster
                this.mouseRaycaster.setFromCamera(this.mouse, this.camera);

                // Find intersections
                const intersectableObjects = [
                    ...this.objects,
                    ...this.menuButtons
                ];

                const intersects = this.mouseRaycaster.intersectObjects(intersectableObjects);

                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    this.handleObjectInteraction(object, null, null);
                }
            }

            handleObjectInteraction(object, controller, controllerIndex) {
                // Handle menu interactions
                if (object.userData.type === 'menuButton') {
                    this.highlightButton(object);
                    
                    // Special handling for GLB button
                    if (object.userData.objectType === 'glb') {
                        if (this.inputMethod.includes('vr')) {
                            console.warn('GLB loading not supported in VR mode');
                            return;
                        }
                        document.getElementById('load-glb-btn').click();
                        return;
                    }
                    
                    this.createObject(object.userData.objectType);
                    return;
                }

                if (object.userData.type === 'deleteButton') {
                    this.highlightButton(object);
                    this.isDeleteMode = !this.isDeleteMode;
                    this.updateDeleteMode();
                    return;
                }

                // Handle object interactions
                if (this.isDeleteMode && object.userData.type === 'interactable') {
                    this.deleteObject(object);
                    return;
                }

                if (object.userData.type === 'interactable') {
                    this.grabObject(object, controller, controllerIndex);
                }
            }

            highlightButton(button) {
                // Reset all buttons to original state
                this.menuButtons.forEach(btn => {
                    btn.material.color.setHex(btn.userData.originalColor);
                    btn.material.opacity = btn.userData.originalOpacity;
                });

                // Highlight clicked button
                button.material.color.setHex(0xFFFFFF);
                button.material.opacity = 1.0;

                // Reset highlight after short delay
                setTimeout(() => {
                    button.material.color.setHex(button.userData.originalColor);
                    button.material.opacity = button.userData.originalOpacity;
                }, 300);
            }

            createObject(type) {
                let geometry;
                const material = new THREE.MeshLambertMaterial({ 
                    color: this.getObjectColor(type)
                });

                // Create geometry based on type
                switch (type) {
                    case 'cube':
                        geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(0.25, 16, 12);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(0.25, 0.25, 0.5, 16);
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(0.25, 0.5, 16);
                        break;
                    case 'torus':
                        geometry = new THREE.TorusGeometry(0.25, 0.1, 8, 16);
                        break;
                    case 'tetrahedron':
                        geometry = new THREE.TetrahedronGeometry(0.3);
                        break;
                    case 'glb':
                        // For the 3D menu button, trigger GLB loading
                        if (this.inputMethod.includes('vr')) {
                            console.warn('GLB loading not supported in VR mode');
                            return;
                        }
                        document.getElementById('load-glb-btn').click();
                        return;
                    default:
                        geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                }

                const object = new THREE.Mesh(geometry, material);
                
                // Random position on platform
                object.position.set(
                    (Math.random() - 0.5) * 3,
                    1 + Math.random() * 0.5,
                    (Math.random() - 0.5) * 3
                );
                
                // Enable shadows
// Enable shadows
                object.castShadow = true;
                object.receiveShadow = true;

                // For GLB models in setupLoadedObject(), add:
                object.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Ensure materials work well with the lighting
                        if (child.material) {
                            child.material.roughness = 0.8; // Softer reflections
                            child.material.metalness = 0.2; // Slight metallic feel
                        }
                    }
                });
                
                // Set user data
                object.userData = { 
                    type: 'interactable',
                    objectType: type,
                    id: Date.now(),
                    created: new Date()
                };

                this.objects.push(object);
                this.scene.add(object);
                
                console.log(`Created ${type} object. Total objects: ${this.objects.length}`);
                this.updateUI();
            }

            deleteObject(object) {
                const index = this.objects.indexOf(object);
                if (index > -1) {
                    this.objects.splice(index, 1);
                    this.scene.remove(object);
                    
                    // Dispose of geometry and material to free memory
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                    
                    console.log(`Deleted object. Total objects: ${this.objects.length}`);
                    this.updateUI();
                }
            }

            grabObject(object, controller, controllerIndex) {
                this.grabbedObject = object;
                this.grabbedController = controllerIndex;
                
                if (controller) {
                    // Calculate grab offset for VR
                    const controllerPosition = new THREE.Vector3();
                    controllerPosition.setFromMatrixPosition(controller.matrixWorld);
                    this.grabOffset.copy(object.position).sub(controllerPosition);
                }
                
                // Store initial rotation
                this.grabRotationOffset.copy(object.quaternion);
                
                // Visual feedback
                if (object.material && object.material.emissive) {
                    object.material.emissive.setHex(0x444444);
                }
                
                console.log('Object grabbed:', object.userData.objectType);
            }

            releaseObject() {
                if (this.grabbedObject) {
                    if (this.grabbedObject.material && this.grabbedObject.material.emissive) {
                        this.grabbedObject.material.emissive.setHex(0x000000);
                    }
                    console.log('Object released:', this.grabbedObject.userData.objectType);
                    this.grabbedObject = null;
                    this.grabbedController = null;
                }
            }

            updateGrabbedObject() {
                if (this.grabbedObject && this.grabbedController !== null && this.controllers[this.grabbedController]) {
                    const controller = this.controllers[this.grabbedController];
                    
                    // Update position
                    const controllerPosition = new THREE.Vector3();
                    controllerPosition.setFromMatrixPosition(controller.matrixWorld);
                    this.grabbedObject.position.copy(controllerPosition).add(this.grabOffset);
                    
                    // Update rotation based on controller rotation
                    const controllerQuaternion = new THREE.Quaternion();
                    controllerQuaternion.setFromRotationMatrix(controller.matrixWorld);
                    this.grabbedObject.quaternion.copy(controllerQuaternion);
                    
                    // Keep object above ground
                    if (this.grabbedObject.position.y < 0.25) {
                        this.grabbedObject.position.y = 0.25;
                    }
                }
            }

            updateDeleteMode() {
                const deleteButton = this.menuButtons.find(btn => 
                    btn.userData.type === 'deleteButton'
                );
                
                if (deleteButton) {
                    const newColor = this.isDeleteMode ? 0x00FF00 : 0xFF0000;
                    deleteButton.material.color.setHex(newColor);
                    deleteButton.userData.originalColor = newColor;
                }

                // Update desktop button
                const toggleDeleteBtn = document.getElementById('toggle-delete');
                if (toggleDeleteBtn) {
                    if (this.isDeleteMode) {
                        toggleDeleteBtn.textContent = 'üóëÔ∏è Delete Mode: ON';
                        toggleDeleteBtn.classList.add('delete-active');
                    } else {
                        toggleDeleteBtn.textContent = 'üóëÔ∏è Delete Mode: OFF';
                        toggleDeleteBtn.classList.remove('delete-active');
                    }
                }
                
                console.log(`Delete mode: ${this.isDeleteMode ? 'ON' : 'OFF'}`);
                this.updateUI();
            }

            updateUI() {
                const count = this.objects.length;
                
                // Update object counts
                document.getElementById('object-count').textContent = `Objects: ${count}`;
                const vrCount = document.getElementById('vr-object-count');
                if (vrCount) vrCount.textContent = `Objects: ${count}`;
                
                // Update input method
                document.getElementById('input-method').textContent = `Input: ${this.inputMethod}`;
                document.getElementById('input-method').className = 
                    `status ${this.inputMethod.includes('vr') ? 'status--success' : 'status--info'}`;
                
                // Update VR mode indicator
                const mode = this.isDeleteMode ? 'Delete' : 'Create';
                const vrMode = document.getElementById('vr-mode-indicator');
                if (vrMode) vrMode.textContent = `Mode: ${mode}`;
            }

            showVRError(message) {
                console.error('VR Error:', message);
                // Could add UI notification here
            }

            loadGLBModel(modelPath) {
                if (!modelPath) {
                    console.error('No model selected');
                    return;
                }

                this.gltfLoader.load(
                    modelPath,
                    (gltf) => {
                        const object = gltf.scene;
                        this.setupLoadedObject(object, modelPath);
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading GLB model:', error);
                    }
                );
            }

            setupLoadedObject(object, name) {
                // Center the object
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                object.position.sub(center);
                
                // Scale the object to a reasonable size
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 0.5 / maxDim;
                object.scale.multiplyScalar(scale);
                
                // Position the object
                object.position.set(
                    (Math.random() - 0.5) * 3,
                    1 + Math.random() * 0.5,
                    (Math.random() - 0.5) * 3
                );
                
                // Enable shadows for all children
                object.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Set user data
                object.userData = {
                    type: 'interactable',
                    objectType: 'glb-model',
                    modelName: name,
                    id: Date.now(),
                    created: new Date()
                };
                
                this.objects.push(object);
                this.scene.add(object);
                
                console.log(`Loaded GLB model: ${name}. Total objects: ${this.objects.length}`);
                this.updateUI();
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());

                // Mouse interaction for desktop
                this.renderer.domElement.addEventListener('click', (e) => this.handleMouseInteraction(e));

                // Desktop creation buttons
                const createButtons = document.querySelectorAll('.create-btn');
                createButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        const type = e.target.dataset.type;
                        if (type) {
                            this.createObject(type);
                            console.log(`Desktop button clicked: ${type}`);
                        }
                    });
                });

                // Headlamp controls
                // Sun position controls
                const sunMorning = document.getElementById('sun-morning');
                if (sunMorning) {
                    sunMorning.addEventListener('click', () => {
                        this.sunLight.position.set(10, 8, 10);
                        this.sunLight.intensity = 0.6;
                        this.sunLight.color.set(0xffcc99);
                        console.log("Sun position: Morning");
                    });
                }

                const sunNoon = document.getElementById('sun-noon');
                if (sunNoon) {
                    sunNoon.addEventListener('click', () => {
                        this.sunLight.position.set(5, 15, 5);
                        this.sunLight.intensity = 0.9;
                        this.sunLight.color.set(0xffffff);
                        console.log("Sun position: Noon");
                    });
                }

                const sunEvening = document.getElementById('sun-evening');
                if (sunEvening) {
                    sunEvening.addEventListener('click', () => {
                        this.sunLight.position.set(-10, 6, -10);
                        this.sunLight.intensity = 0.5;
                        this.sunLight.color.set(0xffaa77);
                        console.log("Sun position: Evening");
                    });
                }

                // GLB model loading
                const loadGLBBtn = document.getElementById('load-glb-btn');
                const modelSelect = document.getElementById('glb-model-select');
                
                if (loadGLBBtn && modelSelect) {
                    loadGLBBtn.addEventListener('click', () => {
                        const selectedModel = modelSelect.value;
                        if (selectedModel) {
                            this.loadGLBModel(selectedModel);
                        }
                    });
                }

                // Close buttons for dialogs
                const closeError = document.getElementById('close-error');
                if (closeError) {
                    closeError.addEventListener('click', () => {
                        document.getElementById('error-panel').classList.add('hidden');
                    });
                }

                const closeTroubleshoot = document.getElementById('close-troubleshoot');
                if (closeTroubleshoot) {
                    closeTroubleshoot.addEventListener('click', () => {
                        document.getElementById('troubleshooting').classList.add('hidden');
                    });
                }

                // VR session events
                if (this.renderer.xr) {
                    this.renderer.xr.addEventListener('sessionstart', () => {
                        console.log('VR session started');
                        document.body.classList.add('vr-mode');
                        document.getElementById('vr-overlay').classList.remove('hidden');
                        this.inputMethod = 'vr-session';
                        this.updateUI();
                    });

                    this.renderer.xr.addEventListener('sessionend', () => {
                        console.log('VR session ended');
                        document.body.classList.remove('vr-mode');
                        document.getElementById('vr-overlay').classList.add('hidden');
                        this.inputMethod = 'desktop';
                        this.updateUI();
                        
                        // Show desktop instructions again
                        document.getElementById('vr-instructions').classList.add('hidden');
                        document.getElementById('desktop-instructions').classList.remove('hidden');
                    });
                }

                // Retry WebXR button
                const retryButton = document.getElementById('retry-webxr');
                if (retryButton) {
                    retryButton.addEventListener('click', async () => {
                        console.log('Retrying WebXR detection...');
                        retryButton.disabled = true;
                        retryButton.textContent = 'üîÑ Checking...';
                        
                        try {
                            await this.checkWebXRCompatibility();
                            this.updateCompatibilityUI();
                            await this.setupVR();
                            console.log('WebXR retry completed');
                        } catch (error) {
                            console.error('WebXR retry failed:', error);
                        }
                        
                        setTimeout(() => {
                            retryButton.disabled = false;
                            retryButton.textContent = 'üîÑ Retry WebXR Detection';
                        }, 2000);
                    });
                }

                // Keyboard controls for desktop
                document.addEventListener('keydown', (event) => this.onKeyDown(event));
            }

            onKeyDown(event) {
                if (this.inputMethod.includes('vr')) return; // Skip keyboard in VR mode
                
                switch (event.code) {
                    case 'KeyC':
                        this.createObject('cube');
                        break;
                    case 'KeyS':
                        this.createObject('sphere');
                        break;
                    case 'KeyT':
                        this.createObject('torus');
                        break;
                    case 'KeyD':
                        this.isDeleteMode = !this.isDeleteMode;
                        this.updateDeleteMode();
                        break;
                    case 'Escape':
                        if (this.grabbedObject) {
                            this.releaseObject();
                        }
                        break;
                }
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.renderer.setAnimationLoop(() => {
                    // Update controls (desktop mode)
                    if (this.controls && !this.renderer.xr.isPresenting) {
                        this.controls.update();
                    }
                    
                    // Update grabbed object
                    this.updateGrabbedObject();
                    
                    // Render
                    this.renderer.render(this.scene, this.camera);
                });
            }
        }

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing VR Object Creator...');
            try {
                new VRObjectCreator();
            } catch (error) {
                console.error('Failed to initialize VR Object Creator:', error);
                
                // Show error in UI
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.innerHTML = `
                        <div class="loading-content">
                            <div style="color: var(--color-error); font-size: var(--font-size-xl); margin-bottom: var(--space-16);">
                                ‚ùå Application Failed to Load
                            </div>
                            <div style="font-size: var(--font-size-md); margin-bottom: var(--space-16);">
                                ${error.message}
                            </div>
                            <button onclick="location.reload()" class="btn btn--primary">
                                üîÑ Reload Page
                            </button>
                        </div>
                    `;
                }
            }
        });

        // Handle page visibility changes for performance
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden - reducing performance');
            } else {
                console.log('Page visible - resuming full performance');
            }
        });
    </script>
</body>
</html>